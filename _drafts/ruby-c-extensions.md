---
layout: post
title: "Extending Ruby with C for Fun and Profit"
---

If you're a Ruby hacker, you probably love Ruby because it's elegant, fun, and
is a language that "just works". In this day and age, the kind of performance
that generally matters the most programmer performance, and Ruby is great at
making happy programmers.

But sometimes Ruby alone isn't the best tool for the job. Maybe you need
performance, or you absolutely need to integrate with a library that only has C
bindings. For cases like these, an awesome tool to have in your Ruby toolcase is
Ruby C extensions. You can write performance-critical code in C, and write the
rest of your code in Ruby. From the Ruby side, you'll never be able to tell the
difference.

The process of making an extension is a piece of cake to use when you know what
you're doing, but good tutorials on how to go from zero to a working extension
are rather lacking on the Web, so I'm making the 10-minute tutorial I wish I
had.

In this guide we'll set up a minimal gem that features C extensions, then build
on that to teach Ruby arrays how to average themselves before finally adding
linked lists to Ruby. The only assumption I'm making is that you're familiar
with Ruby and that you've had some experience with a curly-bracket language (C,
Java, etc.).

### Setting things up

The easiest way to get started is to let Bundler create a skeleton gem for us.
I'll just call the gem "extension cord" because I'm so clever:

```
$ bundle gem extension_cord
$ cd extension_cord
```

This is what Bundler created for us:

```
$ tree .
.
├── Gemfile
├── LICENSE.txt
├── README.md
├── Rakefile
├── extension_cord.gemspec
└── lib
    ├── extension_cord
    │   └── version.rb
    └── extension_cord.rb

2 directories, 7 files
```

At this point, there are multiple options as to how you could go about making
your extension, but the easiest way is to use [Rake-Compiler][rake-compiler],
which takes care of the nitty-gritty aspects of mixing Ruby and C.

So, to get rake-compiler to work, we first need to install it. Modify your
gemspec and add this dependency:

```ruby
# extension_cord.gemspec

Gem::Specification.new do |spec|
  # snip
  spec.add_development_dependency "rake-compiler"
end

```

Then `bundle install` it.

Next, we need to add a rake task for compiling our C extensions, and to do this
we add the following to our `Rakefile`:

```ruby
require 'rake/extensiontask'

Rake::ExtensionTask.new('extension_cord')
```

If you did that right, then the command `rake -T` should include, among other
things, a `rake compile` task.

Though rake-compiler is now set up, we still need to do a little bit of work
before we can get started on our gem. Rake-compiler is convention over
configuration by default, and so it assumes that we will put all of our C code
in the directory `ext/<gem name>/`. Within the directory, rake-compiler expects
a file called `extconf.rb`, as well as a C file called `<gem name>.c`.

Let's set that up. Create an `ext/extension_cord` directory, and in there create
an `extconf.rb` that contains the following:

```ruby
# ext/extension_cord/extconf.rb

require 'mkmf'

create_makefile('extension_cord')
```

`mkmf` is a Ruby library for creating *Makefiles*, which detail how a C project
is supposed to be compiled. The basic makefile generated by this code will be
enough for our purposes, but if you ever need something more sophisticated you
should check out `mkmf`'s docs [here][mkmf-docs].

Next, let's make our `extension_cord.c` file. For now, let's just make a bare-
bones C extension. Write the following into
`ext/extension_cord/extension_cord.c`:

```c
#include "ruby.h"

void Init_extension_cord() {
  printf("Hi Ruby! I'm written in C!\n");
}
```

Okay, so now, we'll compile everything by running the command

```
rake compile
```

Hopefully, you'll get a bunch of lines of commands that rake-compiler is running
for you. If not, you should look into what error is being produced. It might be
that you don't have a C compiler working. If that's the case, then you'll have
to set that up, and I trust you have the ability to use Google to figure that
all out. From this point on I'll assume you could get everything to compile.

In the C snippet above we `include`d `ruby.h`, a *header* file that describes
all the functions Ruby provides for us to use in our code. We then basically
make a hello-world program in a function called `Init_extension_cord`.

People who've programmed in C or any similar language before might wonder how
this code could possibly be useful. What is `Init_extension_cord()` supposed to
be doing? Where is `main()`?

This C code we've written is not the "entrypoint" into any program; when we start
Ruby, we don't expect our C extension to be called right away. We only expect
this C code to begin to be executed when we `require` it from our Ruby code, and
that's where the `Init_<gem name>` function enters: it's the function Ruby calls
when you `require` the file/gem called `extension_cord`.

Except that doesn't quite work yet:

```
$ bundle exec irb
irb(main):001:0> require 'extension_cord'
=> true
irb(main):002:0> ExtensionCord::VERSION
=> "0.0.1"
```

That's weird. The require working almost fine (after all, Ruby now knows about
`ExtensionCord` and its `VERSION`, which is defined in
`lib/extension_cord/version.rb`). Ruby is finding the Ruby code defining
`VERSION`, but it doesn't seem to be finding our C code.

The reason is really dumb. Take a look at the files that are in our gem so
far:

```
$ tree
.
├── Gemfile
├── Gemfile.lock
├── LICENSE.txt
├── README.md
├── Rakefile
├── ext
│   └── extension_cord
│       ├── extconf.rb
│       └── extension_cord.c
├── extension_cord.gemspec
├── lib
│   ├── extension_cord
│   │   └── version.rb
│   ├── extension_cord.bundle
│   └── extension_cord.rb

 -- snip --

10 directories, 15 files
```

Look at the `lib/` directory: there are two files called `extension_cord`; one's
an `.rb` file that Bundler created for us with the `bundle gem` command, and the
other is one that rake-compiler generated for us and kindly placed in the `lib/`
folder. When we do `require extension_cord`, Ruby will pick up the Ruby file
type first, and then ignore the other file of the same name. To fix this, we can
tell Ruby that we also want the C-generated file to be required as well:

```ruby
# lib/extension_cord.rb

require 'extension_cord/version'
require 'extension_cord.so' # add this line

module ExtensionCord
  # Your code goes here...
end
```

"But Wait!" you interject -- what if on my platform, the compiled C became a
`.dll` or `.bundle`, not a `.so`? That's fine. Ruby's `require` is a clever
method and it'll know to use your system's extension (Proof: see how on my
system `rake compile` created a `.bundle`, but requiring a `.so` worked fine
too).

Let's verify that our setup worked:

```
$ bundle exec irb
irb(main):001:0> require 'extension_cord'
Hi Ruby! I'm written in C!
=> true
```

Hooray! We've succesfully gotten a C function (our `printf`) to be called from
Ruby.

If you thought this whole ordeal was very annoying, I'm totally in agreement
with you. However, now that the hard work has been done, from here on out things
get a lot more interesting as we explore the actual C interface and begin using
the really cool stuff that can emerge when we combine C with Ruby's awesome API.

### Writing `avg_of_array` in C

So in this section, we're going to work toward adding a method to Ruby's `Array`
class that lets us find the average of an array. Obviously, this is a pretty
trivial thing to do in Ruby, but the goal here is to get a taste of what Ruby-C
is like.

As a simple first step, let's define a basic Ruby method from within C. To do
this, 'm going to make a few modifications to `extension_cord.c`. Hopefully the
comments will explain what's going on.

```c
// ext/extension_cord/extension_cord.c

#include "ruby.h"

// This is a C variable to represent the Ruby ExtensionCord module we're working
// with.
//
// This is the first of many variables that will be declared with type 'VALUE'.
// Ruby is a dynamically-typed language, but C is statically typed. To
// circumvent this, Ruby provides C code with a 'VALUE' type that can represent
// any Ruby variable (be it a class, module, string, symbol, etc.).
VALUE ExtensionCord;

// This is just a regular C function. Ignore the "self" value for now.
VALUE ocho_cinco(VALUE self) {
  // We can't just return "85" -- 85 is a C "int", not a Ruby Fixnum. To convert
  // C ints into Ruby Numerics, we use the INT2NUM macro that Ruby helpfully
  // provides.
  return INT2NUM(85);
}

// This is the function Ruby calls when this file gets required.
void Init_extension_cord() {

  // This gets the "ExtensionCord" module, or creates it if it doesn't already
  // exist. rb_define_module returns a VALUE that represents a module, and we'll
  // store that module in the variable declared at the top of this file.
  ExtensionCord = rb_define_module("ExtensionCord");

  // This is how C code can define a Ruby method. The define_singleton_method
  // function takes as arguments:
  //   - the module you're adding this method to: in this case, ExtensionCord
  //   - the Ruby-side name of the method (that is, the name of the method as it
  //     will be seen from Ruby), as a string: in this case, "ocho_cinco"
  //   - the C-side function where you actually implement this method: in this
  //     case, the function ocho_cinco we defined earlier
  //   - the number of arguments this method takes: in this case, 0
  rb_define_singleton_method(ExtensionCord, "ocho_cinco", ocho_cinco, 0);
}
```

Basically, the above code is the C equivalent of this in Ruby:

```ruby
module ExtensionCord
  def ocho_cinco
    85
  end
end
```

To verify that this code works, compile it using `rake compile` (I'll assume you
will know to do this on your own from now on), then try seeing if we have access
to the `ocho_cinco` method we tried to define.

```
$ bundle exec irb
irb(main):001:0> require 'extension_cord'
=> true
irb(main):002:0> ExtensionCord.ocho_cinco
=> 85
```

Alrighty, that worked quite nicely. Now let's make a function that averages an
array. To do this, we need to be able to find the C counterparts to Ruby's
`Array#at` and `Array#length` methods. By reading the
[Readme.ext][readme-ext-ary] or by looking at the source code for
[Array#length][ruby-src-ary-length] and [Array#at][ruby-src-ary-at], we can see
that the functions of interest are:

* `RARRY_LEN` (gets the length of an array)
* `rb_ary_entry` (gets the *n*th element in an array)

Knowing that, we can define the `average_of_array` function quite easily.

```c
#include "ruby.h"

VALUE ExtensionCord;

// The "array" VALUE that is passed to this function is expected to be a Ruby
// Array instance. Thus, we'll be able to use rb_ary_* methods on this array
// as though it were just a regular Ruby array.
VALUE avg_of_array(VALUE self, VALUE array) {
  double sum = 0;

  // NUM2INT converts a Ruby Fixnum into a C int. It is the opposite of INT2NUM.
  for (int i = 0; i < RARRAY_LEN(array); i++) {
    sum += NUM2INT(rb_ary_entry(array, i));
  }

  double average = sum / RARRAY_LEN(array);

  // There is no DOUBLE2NUM macro. Use rb_float_new for this instead.
  return rb_float_new(average);
}

void Init_extension_cord() {
  ExtensionCord = rb_define_module("ExtensionCord");

  // note that we're telling Ruby that the "avg_of_ary" method takes 1 argument.
  rb_define_singleton_method(ExtensionCord, "avg_of_array", avg_of_array, 1);
}
```

Let's check that this method works (remember to recompile using `rake compile`):

```
irb(main):001:0> require 'extension_cord'
=> true
irb(main):002:0> ExtensionCord.avg_of_array([1, 1, 1, 7])
=> 2.5
```

That's success right there!

If you're now skeptical as to whether writing performance-critical code in C is
really worth the effort, I've made a benchmark that shows that this simple
averaging function in C is about five times faster than any Ruby averaging
function I could think of. You check out the benchmark as a gist
[here][gist-avg-perf].

Now that we the basics down, let's dive into making a linked list data structure
for Ruby. This will be more involved; we'll talk about creating classes,
including modules, and managing memory from a C extension.

### Creating a linked list in Ruby-C

Let's begin by defining a bare-bones implementation of a linked list. We'll
define these in `linked_list.h` and `linked_list.c`:

```c
// linked_list.h

#ifndef _LINKED_LIST_H
#define _LINKED_LIST_H

#include "ruby.h"

typedef struct node_s {
  struct node_s *next;
  VALUE value;
} node_t;

typedef struct list_s {
  node_t *head;
} list_t;

list_t *list_new();

list_t *list_prepend(list_t *list, VALUE value);
VALUE list_dequeue(list_t *list);

#endif
```

```c
// linked_list.c

#include "linked_list.h"

static node_t *node_new(VALUE value) {
  node_t *node = ALLOC(node_t);
  node->value = value;
  return node;
}

list_t *list_new() {
  list_t *list = ALLOC(list_t);
  list->head = NULL;
  return list;
}

list_t *list_prepend(list_t *list, VALUE value) {
  node_t *node = node_new(value);

  node->next = list->head;
  list->head = node;

  return list;
}

VALUE list_dequeue(list_t *list) {
  node_t *head = list->head;
  list->head = head->next;

  return head->value;
}
```

Before we can start working with these linked lists, we need to tell Ruby how to
create a linked list, and we also need to define a linked list. Here's how we do
that (note that I've removed the average-of-array stuff because we don't really
need it any longer.)

```c
#include "ruby.h"
#include "linked_list.h"

VALUE ExtensionCord;
VALUE LinkedList;

VALUE alloc_list(VALUE klass) {
  list_t *list = list_new();

  return Data_Wrap_Struct(LinkedList, 0, 0, list);
}

void Init_extension_cord() {
  ExtensionCord = rb_define_module("ExtensionCord");
  LinkedList = rb_define_class_under(ExtensionCord, "LinkedList", rb_cObject);

  rb_define_alloc_func(LinkedList, alloc_list);
}
```

`rb_define_class` and `rb_define_class_under` are the functions C extensions use
to define classes. The call to `rb_define_class_under(ExtensionCord,
"LinkedList")` is what in Ruby-land would be:

```ruby
module ExtensionCord
  # Ruby classes by default inherit from Object, but C-created classes do not.
  # This is why in C we had to specify that our class inherits from
  # rb_cObject, which is what the Object class is called in C-land.
  class LinkedList < Object
  end
end
```

Next, the `rb_define_alloc_func` function tells Ruby how to allocate memory for
a new instance of a class. We tell Ruby to alloc using `alloc_list`, which uses
Ruby's `Data_Wrap_Struct` function, which takes four arguments:

  * The class we're instantiating from (`ExtensionCord::LinkedList`),
  * Two arguments for the Ruby garbage collector, which we're not dealing with
    yet, and
  * The C structure we're wrapping.

With just this code, Ruby already can create linked lists for us:

```
$ bundle exec irb
2.0.0-p353 :001 > require 'extension_cord'
 => true
2.0.0-p353 :002 > ExtensionCord::LinkedList
 => ExtensionCord::LinkedList
2.0.0-p353 :003 > ExtensionCord::LinkedList.new
 => #<ExtensionCord::LinkedList:0x007ff8345663f8>
```

Now we want to define a constructor for linked lists that will create a list
from an arbitrary number of arguments, which will allow us to make lists like
so:

```ruby
ExtensionCord::LinkedList.new
ExtensionCord::LinkedList.new("a", :b, nil, /foobar/)
```

Doing so will require that we define a variadic constructor which will accept an
arbitrary number of arguments. We can achieve this by passing -2 as the number
of arguments to our method. Doing so will tell Ruby to accept all arguments
passed to our method and provide it to us as an `Array` (a Ruby array).

Hopefully this example will illustrate how this works:

```c
// -- snip --

VALUE initialize(VALUE self, VALUE args) {
  // 'args' is a Ruby array. That means you can use `rb_ary_entry` or
  // `RARRAY_LEN` or any other Ruby array method on 'args'.
  printf("You gave me %ld arguments.\n", RARRAY_LEN(args));
  return self;
}

void Init_extension_cord() {
  ExtensionCord = rb_define_module("ExtensionCord");
  LinkedList = rb_define_class_under(ExtensionCord, "LinkedList", rb_cObject);

  rb_define_alloc_func(LinkedList, alloc_list);
  rb_define_method(LinkedList, "initialize", initialize, -2);
}
```

```
$ bundle exec irb
2.0.0-p353 :001 > require 'extension_cord'
 => true
2.0.0-p353 :002 > ExtensionCord::LinkedList.new
You gave me 0 arguments.
 => #<ExtensionCord::LinkedList:0x007f9dea4cd3a0>
2.0.0-p353 :003 > ExtensionCord::LinkedList.new("a", "b", "c")
You gave me 3 arguments.
 => #<ExtensionCord::LinkedList:0x007f9dea4dfcf8>
```

[windows-how-to]: http://blogs.law.harvard.edu/hoanga/2006/12/14/getting-a-ruby-c-extension-to-compile-on-windows/
[rake-compiler]: https://github.com/luislavena/rake-compiler
[mkmf-docs]: http://ruby-doc.org/stdlib-2.0/libdoc/mkmf/rdoc/MakeMakefile.html
[readme-ext-ary]: https://github.com/ruby/ruby/blob/trunk/README.EXT#L250
[ruby-github]: https://github.com/ruby/ruby
[ruby-src-ary-length]: https://github.com/ruby/ruby/blob/684f04c15f79a6d9a2040980c69bc392ff0d7159/array.c#L1871
[ruby-src-ary-at]: https://github.com/ruby/ruby/blob/684f04c15f79a6d9a2040980c69bc392ff0d7159/array.c#L1289
[gist-avg-perf]: https://gist.github.com/ulyssecarion/8629784
